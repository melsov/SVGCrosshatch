using g3;
using SCParse;
using UnityEngine;

namespace SCGenerator
{
    [System.Serializable]
    public class MachineConfig : MonoBehaviour
    {
        [Header("Origin")]
        public Vector3 minTravelMM = Vector3.zero;

        [Header("Soft limits from origin XYZ")]
        public Vector3 maxTravelMM = new Vector3(300f, 300f, 20f);

        [Header("Max push-into-paper, cut into material distance")]
        double _maxPenetrationDepthMM = -1d;
        public double maxPenetrationDepthMM {
            get { return _maxPenetrationDepthMM; }
            set {
                _maxPenetrationDepthMM = MathUtil.Clamp(value, -3, 12);
            }
        }

        [SerializeField, Header("Travel height")]
        double _travelHeightMM = 5d;
        public double travelHeightMM {
            get { return _travelHeightMM; }
            set {
                _travelHeightMM = MathUtil.Clamp(value, -3, 24);
            }
        }

        [Header("Drill bit diameter or for a pen: line width at max 'penetration'")]
        public double toolDiameterMM = 2f;

        [Header("Home offset")]
        public Vector3 homePositionOffsetMM = Vector3.zero;

        [Header("Push pen along surface speed")]
        public float feedRateMMS = 400f;

        [Header("Travel above surface speed")]
        public float travelRateMMS = 600f;

        [Header("Pull out/up rate")]
        public float zUpTravelRateMMS = 500f;

        [Header("Push down onto paper/material rate")]
        public float penetrationRateMMS = 100f;

        [Header("How many decimal places in gcode coordinates")]
        public int moveCoordFloatPrecision = 4;

        [TextArea]
        public string header = @"
%
(Header)
(Generated by SVGCrosshatch.)
M3
(Header end.)
G21 (All units in mm) ";

        [TextArea]
        public string footer = @"
(Footer)
( dont need stop spindle from turning M5)
( dont need. added return home in gcode writer G00 X0.0000 Y0.0000)
M2
(Footer end)
% ";

        [SerializeField, Header("Paper min, max (abs) corner positions in mm. Leave blank for default 8.5x11")]
        private Box2 _paper;
        public Box2 paper {
            get {
                if(_paper == null || _paper.size.sqrMagnitude < locationEqualityEpsilonMM) {
                    _paper = new Box2() { min = Vector2.zero, max = new Vector2(8.5f * 25.4f, 11f * 25.4f) };
                }
                return _paper;
            }
            set {
                _paper = value;
            }
        }

        private double locationEqualityEpsilonMM = .1d;

        public Vector3 size {
            get { return maxTravelMM - minTravelMM; }
        }

        public Vector3 center {
            get {
                return minTravelMM + size / 2f;
            }
        }

        public Rect boundsXY {
            get {
                return new Rect(minTravelMM.x, minTravelMM.y, size.x, size.y); 
            }
        }

        public bool isSameXY(Vector2f a, Vector2f b) {
            return (a - b).LengthSquared < locationEqualityEpsilonMM * locationEqualityEpsilonMM;
        }

        public bool isSamePenMove(PenMove a, PenMove b) {
            return a.up == b.up && isSameXY(a.destination, b.destination);
        }

        public Vector3f getPosition(PenMove pm) {
            return new Vector3f(pm.destination.x, pm.destination.y, pm.up ? travelHeightMM : maxPenetrationDepthMM);
        }

        //TODO: systematize gradual penetration, moveFeed at a given strata (for milling wood, etc.) 

        public Vector3d moveXYFeed(Vector2d v) {
            return moveXY(v, maxPenetrationDepthMM);
        }
        
        public Vector3d moveXYTravel(Vector2d v) {
            return moveXY(v, travelHeightMM);
        }

        public Vector3d moveXY(Vector2d v, double z) {
            return new Vector3d(v.x, v.y, z);
        } 

        public bool isAtTravelHeight(Vector3d v) {
            return MathUtil.EpsilonEqual(v.z, travelHeightMM, locationEqualityEpsilonMM);
        }

        public bool isAtMaxPenetrationDepth(Vector3d v) {
            return MathUtil.EpsilonEqual(v.z, maxPenetrationDepthMM, locationEqualityEpsilonMM);
        }

        

    }

    public class MachineConfigMB : MonoBehaviour
    {
        public MachineConfig machineConfig;
    }
    
}
